# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ChallengeDynamicRequirements',
    'ChallengeStandardRequirements',
    'GetBracketsUserResult',
    'GetChallengesDynamicChallengeResult',
    'GetChallengesDynamicChallengeRequirementsResult',
    'GetChallengesStandardChallengeResult',
    'GetChallengesStandardChallengeRequirementsResult',
    'GetTeamsTeamResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class ChallengeDynamicRequirements(dict):
    def __init__(__self__, *,
                 behavior: Optional[builtins.str] = None,
                 prerequisites: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[builtins.str] prerequisites: List of the challenges ID.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if prerequisites is not None:
            pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[builtins.str]:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


@pulumi.output_type
class ChallengeStandardRequirements(dict):
    def __init__(__self__, *,
                 behavior: Optional[builtins.str] = None,
                 prerequisites: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[builtins.str] prerequisites: List of the challenges ID.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if prerequisites is not None:
            pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[builtins.str]:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


@pulumi.output_type
class GetBracketsUserResult(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str description: Description that explains the goal of this bracket.
        :param builtins.str id: Identifier of the bracket, used internally to handle the CTFd corresponding object.
        :param builtins.str name: Name displayed to end-users (e.g. "Students", "Interns", "Engineers").
        :param builtins.str type: Type of the bracket, either "users" or "teams".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description that explains the goal of this bracket.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Identifier of the bracket, used internally to handle the CTFd corresponding object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name displayed to end-users (e.g. "Students", "Interns", "Engineers").
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the bracket, either "users" or "teams".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetChallengesDynamicChallengeResult(dict):
    def __init__(__self__, *,
                 attribution: builtins.str,
                 category: builtins.str,
                 connection_info: builtins.str,
                 decay: builtins.int,
                 description: builtins.str,
                 function: builtins.str,
                 id: builtins.str,
                 max_attempts: builtins.int,
                 minimum: builtins.int,
                 name: builtins.str,
                 next: builtins.int,
                 requirements: 'outputs.GetChallengesDynamicChallengeRequirementsResult',
                 state: builtins.str,
                 tags: Sequence[builtins.str],
                 topics: Sequence[builtins.str],
                 value: builtins.int):
        """
        :param builtins.str attribution: Attribution to the creator(s) of the challenge.
        :param builtins.str category: Category of the challenge that CTFd groups by on the web UI.
        :param builtins.str connection_info: Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        :param builtins.int decay: The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.
        :param builtins.str description: Description of the challenge, consider using multiline descriptions for better style.
        :param builtins.str function: Decay function to define how the challenge value evolve through solves, either linear or logarithmic.
        :param builtins.str id: Identifier of the challenge.
        :param builtins.int max_attempts: Maximum amount of attempts before being unable to flag the challenge.
        :param builtins.int minimum: The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.
        :param builtins.str name: Name of the challenge, displayed as it.
        :param builtins.int next: Suggestion for the end-user as next challenge to work on.
        :param 'GetChallengesDynamicChallengeRequirementsArgs' requirements: List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        :param builtins.str state: State of the challenge, either hidden or visible.
        :param Sequence[builtins.str] tags: List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        :param Sequence[builtins.str] topics: List of challenge topics that are displayed to the administrators for maintenance and planification.
        :param builtins.int value: The value (points) of the challenge once solved. It is mapped to `initial` under the hood, but displayed as `value` for consistency with the standard challenge.
        """
        pulumi.set(__self__, "attribution", attribution)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "connection_info", connection_info)
        pulumi.set(__self__, "decay", decay)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "requirements", requirements)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def attribution(self) -> builtins.str:
        """
        Attribution to the creator(s) of the challenge.
        """
        return pulumi.get(self, "attribution")

    @property
    @pulumi.getter
    def category(self) -> builtins.str:
        """
        Category of the challenge that CTFd groups by on the web UI.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> builtins.str:
        """
        Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter
    def decay(self) -> builtins.int:
        """
        The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.
        """
        return pulumi.get(self, "decay")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description of the challenge, consider using multiline descriptions for better style.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def function(self) -> builtins.str:
        """
        Decay function to define how the challenge value evolve through solves, either linear or logarithmic.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Identifier of the challenge.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> builtins.int:
        """
        Maximum amount of attempts before being unable to flag the challenge.
        """
        return pulumi.get(self, "max_attempts")

    @property
    @pulumi.getter
    def minimum(self) -> builtins.int:
        """
        The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the challenge, displayed as it.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def next(self) -> builtins.int:
        """
        Suggestion for the end-user as next challenge to work on.
        """
        return pulumi.get(self, "next")

    @property
    @pulumi.getter
    def requirements(self) -> 'outputs.GetChallengesDynamicChallengeRequirementsResult':
        """
        List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        """
        return pulumi.get(self, "requirements")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the challenge, either hidden or visible.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[builtins.str]:
        """
        List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[builtins.str]:
        """
        List of challenge topics that are displayed to the administrators for maintenance and planification.
        """
        return pulumi.get(self, "topics")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        The value (points) of the challenge once solved. It is mapped to `initial` under the hood, but displayed as `value` for consistency with the standard challenge.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChallengesDynamicChallengeRequirementsResult(dict):
    def __init__(__self__, *,
                 behavior: builtins.str,
                 prerequisites: Sequence[builtins.str]):
        """
        :param builtins.str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[builtins.str] prerequisites: List of the challenges ID.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> builtins.str:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Sequence[builtins.str]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


@pulumi.output_type
class GetChallengesStandardChallengeResult(dict):
    def __init__(__self__, *,
                 attribution: builtins.str,
                 category: builtins.str,
                 connection_info: builtins.str,
                 description: builtins.str,
                 id: builtins.str,
                 max_attempts: builtins.int,
                 name: builtins.str,
                 next: builtins.int,
                 requirements: 'outputs.GetChallengesStandardChallengeRequirementsResult',
                 state: builtins.str,
                 tags: Sequence[builtins.str],
                 topics: Sequence[builtins.str],
                 value: builtins.int):
        """
        :param builtins.str attribution: Attribution to the creator(s) of the challenge.
        :param builtins.str category: Category of the challenge that CTFd groups by on the web UI.
        :param builtins.str connection_info: Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        :param builtins.str description: Description of the challenge, consider using multiline descriptions for better style.
        :param builtins.str id: Identifier of the challenge.
        :param builtins.int max_attempts: Maximum amount of attempts before being unable to flag the challenge.
        :param builtins.str name: Name of the challenge, displayed as it.
        :param builtins.int next: Suggestion for the end-user as next challenge to work on.
        :param 'GetChallengesStandardChallengeRequirementsArgs' requirements: List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        :param builtins.str state: State of the challenge, either hidden or visible.
        :param Sequence[builtins.str] tags: List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        :param Sequence[builtins.str] topics: List of challenge topics that are displayed to the administrators for maintenance and planification.
        """
        pulumi.set(__self__, "attribution", attribution)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "connection_info", connection_info)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "requirements", requirements)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def attribution(self) -> builtins.str:
        """
        Attribution to the creator(s) of the challenge.
        """
        return pulumi.get(self, "attribution")

    @property
    @pulumi.getter
    def category(self) -> builtins.str:
        """
        Category of the challenge that CTFd groups by on the web UI.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> builtins.str:
        """
        Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description of the challenge, consider using multiline descriptions for better style.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Identifier of the challenge.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> builtins.int:
        """
        Maximum amount of attempts before being unable to flag the challenge.
        """
        return pulumi.get(self, "max_attempts")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the challenge, displayed as it.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def next(self) -> builtins.int:
        """
        Suggestion for the end-user as next challenge to work on.
        """
        return pulumi.get(self, "next")

    @property
    @pulumi.getter
    def requirements(self) -> 'outputs.GetChallengesStandardChallengeRequirementsResult':
        """
        List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        """
        return pulumi.get(self, "requirements")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the challenge, either hidden or visible.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[builtins.str]:
        """
        List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[builtins.str]:
        """
        List of challenge topics that are displayed to the administrators for maintenance and planification.
        """
        return pulumi.get(self, "topics")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChallengesStandardChallengeRequirementsResult(dict):
    def __init__(__self__, *,
                 behavior: builtins.str,
                 prerequisites: Sequence[builtins.str]):
        """
        :param builtins.str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[builtins.str] prerequisites: List of the challenges ID.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> builtins.str:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Sequence[builtins.str]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


@pulumi.output_type
class GetTeamsTeamResult(dict):
    def __init__(__self__, *,
                 affiliation: builtins.str,
                 banned: builtins.bool,
                 captain: builtins.str,
                 country: builtins.str,
                 email: builtins.str,
                 hidden: builtins.bool,
                 id: builtins.str,
                 members: Sequence[builtins.str],
                 name: builtins.str,
                 password: builtins.str,
                 website: builtins.str):
        """
        :param builtins.str affiliation: Affiliation to a company or agency.
        :param builtins.bool banned: Is true if the team is banned from the CTF.
        :param builtins.str captain: Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).
        :param builtins.str country: Country the team represent or is hail from.
        :param builtins.str email: Email of the team.
        :param builtins.bool hidden: Is true if the team is hidden to the participants.
        :param builtins.str id: Identifier of the user.
        :param Sequence[builtins.str] members: List of members (User), defined by their IDs.
        :param builtins.str name: Name of the team.
        :param builtins.str password: Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.
        :param builtins.str website: Website, blog, or anything similar (displayed to other participants).
        """
        pulumi.set(__self__, "affiliation", affiliation)
        pulumi.set(__self__, "banned", banned)
        pulumi.set(__self__, "captain", captain)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "hidden", hidden)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "website", website)

    @property
    @pulumi.getter
    def affiliation(self) -> builtins.str:
        """
        Affiliation to a company or agency.
        """
        return pulumi.get(self, "affiliation")

    @property
    @pulumi.getter
    def banned(self) -> builtins.bool:
        """
        Is true if the team is banned from the CTF.
        """
        return pulumi.get(self, "banned")

    @property
    @pulumi.getter
    def captain(self) -> builtins.str:
        """
        Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).
        """
        return pulumi.get(self, "captain")

    @property
    @pulumi.getter
    def country(self) -> builtins.str:
        """
        Country the team represent or is hail from.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def email(self) -> builtins.str:
        """
        Email of the team.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def hidden(self) -> builtins.bool:
        """
        Is true if the team is hidden to the participants.
        """
        return pulumi.get(self, "hidden")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Identifier of the user.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def members(self) -> Sequence[builtins.str]:
        """
        List of members (User), defined by their IDs.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the team.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def website(self) -> builtins.str:
        """
        Website, blog, or anything similar (displayed to other participants).
        """
        return pulumi.get(self, "website")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 affiliation: builtins.str,
                 banned: builtins.bool,
                 country: builtins.str,
                 email: builtins.str,
                 hidden: builtins.bool,
                 id: builtins.str,
                 language: builtins.str,
                 name: builtins.str,
                 password: builtins.str,
                 type: builtins.str,
                 verified: builtins.bool,
                 website: builtins.str):
        """
        :param builtins.str affiliation: Affiliation to a team, company or agency.
        :param builtins.bool banned: Is true if the user is banned from the CTF.
        :param builtins.str country: Country the user represent or is native from.
        :param builtins.str email: Email of the user, may be used to verify the account.
        :param builtins.bool hidden: Is true if the user is hidden to the participants.
        :param builtins.str id: Identifier of the user.
        :param builtins.str language: Language the user is fluent in.
        :param builtins.str name: Name or pseudo of the user.
        :param builtins.str password: Password of the user. Notice that during a CTF you may not want to update those to avoid defaulting user accesses.
        :param builtins.str type: Generic type for RBAC purposes.
        :param builtins.bool verified: Is true if the user has verified its account by email, or if set by an admin.
        :param builtins.str website: Website, blog, or anything similar (displayed to other participants).
        """
        pulumi.set(__self__, "affiliation", affiliation)
        pulumi.set(__self__, "banned", banned)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "hidden", hidden)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "verified", verified)
        pulumi.set(__self__, "website", website)

    @property
    @pulumi.getter
    def affiliation(self) -> builtins.str:
        """
        Affiliation to a team, company or agency.
        """
        return pulumi.get(self, "affiliation")

    @property
    @pulumi.getter
    def banned(self) -> builtins.bool:
        """
        Is true if the user is banned from the CTF.
        """
        return pulumi.get(self, "banned")

    @property
    @pulumi.getter
    def country(self) -> builtins.str:
        """
        Country the user represent or is native from.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def email(self) -> builtins.str:
        """
        Email of the user, may be used to verify the account.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def hidden(self) -> builtins.bool:
        """
        Is true if the user is hidden to the participants.
        """
        return pulumi.get(self, "hidden")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Identifier of the user.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def language(self) -> builtins.str:
        """
        Language the user is fluent in.
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name or pseudo of the user.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        Password of the user. Notice that during a CTF you may not want to update those to avoid defaulting user accesses.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Generic type for RBAC purposes.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def verified(self) -> builtins.bool:
        """
        Is true if the user has verified its account by email, or if set by an admin.
        """
        return pulumi.get(self, "verified")

    @property
    @pulumi.getter
    def website(self) -> builtins.str:
        """
        Website, blog, or anything similar (displayed to other participants).
        """
        return pulumi.get(self, "website")


