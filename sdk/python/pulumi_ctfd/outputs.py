# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ChallengeFile',
    'ChallengeFlag',
    'ChallengeHint',
    'ChallengeRequirements',
    'GetChallengesChallengeResult',
    'GetChallengesChallengeFileResult',
    'GetChallengesChallengeFlagResult',
    'GetChallengesChallengeHintResult',
    'GetChallengesChallengeRequirementsResult',
]

@pulumi.output_type
class ChallengeFile(dict):
    def __init__(__self__, *,
                 name: str,
                 content: Optional[str] = None,
                 contentb64: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None):
        """
        :param str name: Name of the file as displayed to end-users.
        :param str content: Raw content of the file, perfectly fit the use-cases of a .txt document or anything with a simple binary content. You could provide it from the file-system using `file("${path.module}/...")`.
        :param str contentb64: Base 64 content of the file, perfectly fit the use-cases of complex binaries. You could provide it from the file-system using `filebase64("${path.module}/...")`.
        :param str id: Identifier of the file, used internally to handle the CTFd corresponding object.
        :param str location: Location where the file is stored on the CTFd instance, for download purposes.
        """
        pulumi.set(__self__, "name", name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if contentb64 is not None:
            pulumi.set(__self__, "contentb64", contentb64)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the file as displayed to end-users.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Raw content of the file, perfectly fit the use-cases of a .txt document or anything with a simple binary content. You could provide it from the file-system using `file("${path.module}/...")`.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def contentb64(self) -> Optional[str]:
        """
        Base 64 content of the file, perfectly fit the use-cases of complex binaries. You could provide it from the file-system using `filebase64("${path.module}/...")`.
        """
        return pulumi.get(self, "contentb64")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier of the file, used internally to handle the CTFd corresponding object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location where the file is stored on the CTFd instance, for download purposes.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class ChallengeFlag(dict):
    def __init__(__self__, *,
                 content: str,
                 data: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str content: The actual flag to match. Consider using the convention `MYCTF{value}` with `MYCTF` being the shortcode of your event's name and `value` depending on each challenge.
        :param str data: The flag sensitivity information, either case*sensitive or case*insensitive
        :param str id: Identifier of the flag, used internally to handle the CTFd corresponding object.
        :param str type: The type of the flag, could be either static or regex
        """
        pulumi.set(__self__, "content", content)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The actual flag to match. Consider using the convention `MYCTF{value}` with `MYCTF` being the shortcode of your event's name and `value` depending on each challenge.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        The flag sensitivity information, either case*sensitive or case*insensitive
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier of the flag, used internally to handle the CTFd corresponding object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the flag, could be either static or regex
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ChallengeHint(dict):
    def __init__(__self__, *,
                 content: str,
                 cost: Optional[int] = None,
                 id: Optional[str] = None,
                 requirements: Optional[Sequence[str]] = None):
        """
        :param str content: Content of the hint as displayed to the end-user.
        :param int cost: Cost of the hint, and if any specified, the end-user will consume its own (or team) points to get it.
        :param str id: Identifier of the hint, used internally to handle the CTFd corresponding object.
        :param Sequence[str] requirements: Other hints required to be consumed before getting this one. Useful for cost-increasing hint strategies with more and more help.
        """
        pulumi.set(__self__, "content", content)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the hint as displayed to the end-user.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def cost(self) -> Optional[int]:
        """
        Cost of the hint, and if any specified, the end-user will consume its own (or team) points to get it.
        """
        return pulumi.get(self, "cost")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier of the hint, used internally to handle the CTFd corresponding object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def requirements(self) -> Optional[Sequence[str]]:
        """
        Other hints required to be consumed before getting this one. Useful for cost-increasing hint strategies with more and more help.
        """
        return pulumi.get(self, "requirements")


@pulumi.output_type
class ChallengeRequirements(dict):
    def __init__(__self__, *,
                 behavior: Optional[str] = None,
                 prerequisites: Optional[Sequence[str]] = None):
        """
        :param str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[str] prerequisites: List of the challenges ID.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if prerequisites is not None:
            pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[str]:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Optional[Sequence[str]]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


@pulumi.output_type
class GetChallengesChallengeResult(dict):
    def __init__(__self__, *,
                 category: str,
                 connection_info: str,
                 decay: int,
                 description: str,
                 files: Sequence['outputs.GetChallengesChallengeFileResult'],
                 flags: Sequence['outputs.GetChallengesChallengeFlagResult'],
                 function: str,
                 hints: Sequence['outputs.GetChallengesChallengeHintResult'],
                 id: str,
                 max_attempts: int,
                 minimum: int,
                 name: str,
                 next: int,
                 requirements: 'outputs.GetChallengesChallengeRequirementsResult',
                 state: str,
                 tags: Sequence[str],
                 topics: Sequence[str],
                 type: str,
                 value: int):
        """
        :param str category: Category of the challenge that CTFd groups by on the web UI.
        :param str connection_info: Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        :param str description: Description of the challenge, consider using multiline descriptions for better style.
        :param Sequence['GetChallengesChallengeFileArgs'] files: List of files given to players to flag the challenge.
        :param Sequence['GetChallengesChallengeFlagArgs'] flags: List of challenge flags that solves it.
        :param str function: Decay function to define how the challenge value evolve through solves, either linear or logarithmic.
        :param Sequence['GetChallengesChallengeHintArgs'] hints: List of hints about the challenge displayed to the end-user.
        :param str id: Identifier of the challenge.
        :param int max_attempts: Maximum amount of attempts before being unable to flag the challenge.
        :param str name: Name of the challenge, displayed as it.
        :param int next: Suggestion for the end-user as next challenge to work on.
        :param 'GetChallengesChallengeRequirementsArgs' requirements: List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        :param str state: State of the challenge, either hidden or visible.
        :param Sequence[str] tags: List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        :param Sequence[str] topics: List of challenge topics that are displayed to the administrators for maintenance and planification.
        :param str type: Type of the challenge defining its layout, either standard or dynamic.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "connection_info", connection_info)
        pulumi.set(__self__, "decay", decay)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "hints", hints)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_attempts", max_attempts)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next", next)
        pulumi.set(__self__, "requirements", requirements)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Category of the challenge that CTFd groups by on the web UI.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> str:
        """
        Connection Information to connect to the challenge instance, useful for pwn or web pentest.
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter
    def decay(self) -> int:
        return pulumi.get(self, "decay")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the challenge, consider using multiline descriptions for better style.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.GetChallengesChallengeFileResult']:
        """
        List of files given to players to flag the challenge.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def flags(self) -> Sequence['outputs.GetChallengesChallengeFlagResult']:
        """
        List of challenge flags that solves it.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        Decay function to define how the challenge value evolve through solves, either linear or logarithmic.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def hints(self) -> Sequence['outputs.GetChallengesChallengeHintResult']:
        """
        List of hints about the challenge displayed to the end-user.
        """
        return pulumi.get(self, "hints")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the challenge.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> int:
        """
        Maximum amount of attempts before being unable to flag the challenge.
        """
        return pulumi.get(self, "max_attempts")

    @property
    @pulumi.getter
    def minimum(self) -> int:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the challenge, displayed as it.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def next(self) -> int:
        """
        Suggestion for the end-user as next challenge to work on.
        """
        return pulumi.get(self, "next")

    @property
    @pulumi.getter
    def requirements(self) -> 'outputs.GetChallengesChallengeRequirementsResult':
        """
        List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
        """
        return pulumi.get(self, "requirements")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the challenge, either hidden or visible.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        """
        List of challenge topics that are displayed to the administrators for maintenance and planification.
        """
        return pulumi.get(self, "topics")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the challenge defining its layout, either standard or dynamic.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChallengesChallengeFileResult(dict):
    def __init__(__self__, *,
                 content: str,
                 contentb64: str,
                 id: str,
                 location: str,
                 name: str):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "contentb64", contentb64)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def contentb64(self) -> str:
        return pulumi.get(self, "contentb64")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetChallengesChallengeFlagResult(dict):
    def __init__(__self__, *,
                 content: str,
                 data: str,
                 id: str,
                 type: str):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def data(self) -> str:
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetChallengesChallengeHintResult(dict):
    def __init__(__self__, *,
                 content: str,
                 cost: int,
                 id: str,
                 requirements: Sequence[str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "cost", cost)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "requirements", requirements)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def cost(self) -> int:
        return pulumi.get(self, "cost")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def requirements(self) -> Sequence[str]:
        return pulumi.get(self, "requirements")


@pulumi.output_type
class GetChallengesChallengeRequirementsResult(dict):
    def __init__(__self__, *,
                 behavior: str,
                 prerequisites: Sequence[str]):
        """
        :param str behavior: Behavior if not unlocked, either hidden or anonymized.
        :param Sequence[str] prerequisites: List of the challenges ID.
        """
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "prerequisites", prerequisites)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        Behavior if not unlocked, either hidden or anonymized.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def prerequisites(self) -> Sequence[str]:
        """
        List of the challenges ID.
        """
        return pulumi.get(self, "prerequisites")


