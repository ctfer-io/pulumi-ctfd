// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ChallengeDynamicRequirements {
    /**
     * Behavior if not unlocked, either hidden or anonymized.
     */
    behavior: string;
    /**
     * List of the challenges ID.
     */
    prerequisites?: string[];
}

export interface ChallengeStandardRequirements {
    /**
     * Behavior if not unlocked, either hidden or anonymized.
     */
    behavior: string;
    /**
     * List of the challenges ID.
     */
    prerequisites?: string[];
}

export interface GetBracketsUser {
    /**
     * Description that explains the goal of this bracket.
     */
    description: string;
    /**
     * Identifier of the bracket, used internally to handle the CTFd corresponding object.
     */
    id: string;
    /**
     * Name displayed to end-users (e.g. "Students", "Interns", "Engineers").
     */
    name: string;
    /**
     * Type of the bracket, either "users" or "teams".
     */
    type: string;
}

export interface GetChallengesDynamicChallenge {
    /**
     * Attribution to the creator(s) of the challenge.
     */
    attribution: string;
    /**
     * Category of the challenge that CTFd groups by on the web UI.
     */
    category: string;
    /**
     * Connection Information to connect to the challenge instance, useful for pwn or web pentest.
     */
    connectionInfo: string;
    /**
     * The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.
     */
    decay: number;
    /**
     * Description of the challenge, consider using multiline descriptions for better style.
     */
    description: string;
    /**
     * Decay function to define how the challenge value evolve through solves, either linear or logarithmic.
     */
    function: string;
    /**
     * Identifier of the challenge.
     */
    id: string;
    /**
     * Maximum amount of attempts before being unable to flag the challenge.
     */
    maxAttempts: number;
    /**
     * The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.
     */
    minimum: number;
    /**
     * Name of the challenge, displayed as it.
     */
    name: string;
    /**
     * Suggestion for the end-user as next challenge to work on.
     */
    next: number;
    /**
     * List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
     */
    requirements: outputs.GetChallengesDynamicChallengeRequirements;
    /**
     * State of the challenge, either hidden or visible.
     */
    state: string;
    /**
     * List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
     */
    tags: string[];
    /**
     * List of challenge topics that are displayed to the administrators for maintenance and planification.
     */
    topics: string[];
    /**
     * The value (points) of the challenge once solved. It is mapped to `initial` under the hood, but displayed as `value` for consistency with the standard challenge.
     */
    value: number;
}

export interface GetChallengesDynamicChallengeRequirements {
    /**
     * Behavior if not unlocked, either hidden or anonymized.
     */
    behavior: string;
    /**
     * List of the challenges ID.
     */
    prerequisites: string[];
}

export interface GetChallengesStandardChallenge {
    /**
     * Attribution to the creator(s) of the challenge.
     */
    attribution: string;
    /**
     * Category of the challenge that CTFd groups by on the web UI.
     */
    category: string;
    /**
     * Connection Information to connect to the challenge instance, useful for pwn or web pentest.
     */
    connectionInfo: string;
    /**
     * Description of the challenge, consider using multiline descriptions for better style.
     */
    description: string;
    /**
     * Identifier of the challenge.
     */
    id: string;
    /**
     * Maximum amount of attempts before being unable to flag the challenge.
     */
    maxAttempts: number;
    /**
     * Name of the challenge, displayed as it.
     */
    name: string;
    /**
     * Suggestion for the end-user as next challenge to work on.
     */
    next: number;
    /**
     * List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.
     */
    requirements: outputs.GetChallengesStandardChallengeRequirements;
    /**
     * State of the challenge, either hidden or visible.
     */
    state: string;
    /**
     * List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.
     */
    tags: string[];
    /**
     * List of challenge topics that are displayed to the administrators for maintenance and planification.
     */
    topics: string[];
    value: number;
}

export interface GetChallengesStandardChallengeRequirements {
    /**
     * Behavior if not unlocked, either hidden or anonymized.
     */
    behavior: string;
    /**
     * List of the challenges ID.
     */
    prerequisites: string[];
}

export interface GetTeamsTeam {
    /**
     * Affiliation to a company or agency.
     */
    affiliation: string;
    /**
     * Is true if the team is banned from the CTF.
     */
    banned: boolean;
    /**
     * Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).
     */
    captain: string;
    /**
     * Country the team represent or is hail from.
     */
    country: string;
    /**
     * Email of the team.
     */
    email: string;
    /**
     * Is true if the team is hidden to the participants.
     */
    hidden: boolean;
    /**
     * Identifier of the user.
     */
    id: string;
    /**
     * List of members (User), defined by their IDs.
     */
    members: string[];
    /**
     * Name of the team.
     */
    name: string;
    /**
     * Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.
     */
    password: string;
    /**
     * Website, blog, or anything similar (displayed to other participants).
     */
    website: string;
}

export interface GetUsersUser {
    /**
     * Affiliation to a team, company or agency.
     */
    affiliation: string;
    /**
     * Is true if the user is banned from the CTF.
     */
    banned: boolean;
    /**
     * Country the user represent or is native from.
     */
    country: string;
    /**
     * Email of the user, may be used to verify the account.
     */
    email: string;
    /**
     * Is true if the user is hidden to the participants.
     */
    hidden: boolean;
    /**
     * Identifier of the user.
     */
    id: string;
    /**
     * Language the user is fluent in.
     */
    language: string;
    /**
     * Name or pseudo of the user.
     */
    name: string;
    /**
     * Password of the user. Notice that during a CTF you may not want to update those to avoid defaulting user accesses.
     */
    password: string;
    /**
     * Generic type for RBAC purposes.
     */
    type: string;
    /**
     * Is true if the user has verified its account by email, or if set by an admin.
     */
    verified: boolean;
    /**
     * Website, blog, or anything similar (displayed to other participants).
     */
    website: string;
}

