{
    "name": "ctfd",
    "displayName": "CTFd",
    "description": "The CTFd provider for Pulumi, to manage its resources as code.",
    "keywords": [
        "pulumi",
        "ctfd",
        "category/cloud"
    ],
    "homepage": "https://ctfer.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`ctfd` Terraform Provider](https://github.com/ctfer-io/terraform-provider-ctfd).",
    "repository": "https://github.com/ctfer-io/pulumi-ctfd",
    "logoUrl": "https://raw.githubusercontent.com/ctfer-io/pulumi-ctfd/main/res/ctfd.png",
    "pluginDownloadURL": "github://api.github.com/ctfer-io/",
    "publisher": "CTFer.io",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "rootNamespace": "CTFerio"
        },
        "go": {
            "importBasePath": "github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageName": "@ctfer-io/pulumi-ctfd",
            "packageDescription": "The CTFd provider for Pulumi, to manage its resources as code.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ctfer-io/terraform-provider-ctfd)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ctfd` repo](https://github.com/ctfer-io/pulumi-ctfd/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ctfd` repo](https://github.com/ctfer-io/terraform-provider-ctfd/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "packageName": "ctfer-io_pulumi-ctfd",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ctfer-io/terraform-provider-ctfd)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ctfd` repo](https://github.com/ctfer-io/pulumi-ctfd/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ctfd` repo](https://github.com/ctfer-io/terraform-provider-ctfd/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {}
        }
    },
    "config": {
        "variables": {
            "apiKey": {
                "type": "string",
                "description": "User API key. Could use `CTFD_API_KEY` environment variable instead. Despite being the most convenient way to\nauthenticate yourself, we do not recommend it as you will probably generate a long-live token without any rotation\npolicy.\n",
                "secret": true
            },
            "nonce": {
                "type": "string",
                "description": "User session nonce, comes with session. Could use `CTFD_NONCE` environment variable instead.\n",
                "secret": true
            },
            "session": {
                "type": "string",
                "description": "User session token, comes with nonce. Could use `CTFD_SESSION` environment variable instead.\n",
                "secret": true
            },
            "url": {
                "type": "string",
                "description": "CTFd base URL (e.g. `https://my-ctf.lan`). Could use `CTFD_URL` environment variable instead.\n"
            }
        }
    },
    "types": {
        "ctfd:index/ChallengeRequirements:ChallengeRequirements": {
            "properties": {
                "behavior": {
                    "type": "string",
                    "description": "Behavior if not unlocked, either hidden or anonymized.\n"
                },
                "prerequisites": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the challenges ID.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "behavior"
                    ]
                }
            }
        },
        "ctfd:index/getChallengesChallenge:getChallengesChallenge": {
            "properties": {
                "category": {
                    "type": "string",
                    "description": "Category of the challenge that CTFd groups by on the web UI.\n"
                },
                "connectionInfo": {
                    "type": "string",
                    "description": "Connection Information to connect to the challenge instance, useful for pwn or web pentest.\n"
                },
                "decay": {
                    "type": "integer"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the challenge, consider using multiline descriptions for better style.\n"
                },
                "function": {
                    "type": "string",
                    "description": "Decay function to define how the challenge value evolve through solves, either linear or logarithmic.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Identifier of the challenge.\n"
                },
                "maxAttempts": {
                    "type": "integer",
                    "description": "Maximum amount of attempts before being unable to flag the challenge.\n"
                },
                "minimum": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the challenge, displayed as it.\n"
                },
                "next": {
                    "type": "integer",
                    "description": "Suggestion for the end-user as next challenge to work on.\n"
                },
                "requirements": {
                    "$ref": "#/types/ctfd:index/getChallengesChallengeRequirements:getChallengesChallengeRequirements",
                    "description": "List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the challenge, either hidden or visible.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge topics that are displayed to the administrators for maintenance and planification.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the challenge defining its layout, either standard or dynamic.\n"
                },
                "value": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "category",
                "connectionInfo",
                "decay",
                "description",
                "function",
                "id",
                "maxAttempts",
                "minimum",
                "name",
                "next",
                "requirements",
                "state",
                "tags",
                "topics",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ctfd:index/getChallengesChallengeRequirements:getChallengesChallengeRequirements": {
            "properties": {
                "behavior": {
                    "type": "string",
                    "description": "Behavior if not unlocked, either hidden or anonymized.\n"
                },
                "prerequisites": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the challenges ID.\n"
                }
            },
            "type": "object",
            "required": [
                "behavior",
                "prerequisites"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the ctfd package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "apiKey": {
                "type": "string",
                "description": "User API key. Could use `CTFD_API_KEY` environment variable instead. Despite being the most convenient way to\nauthenticate yourself, we do not recommend it as you will probably generate a long-live token without any rotation\npolicy.\n",
                "secret": true
            },
            "nonce": {
                "type": "string",
                "description": "User session nonce, comes with session. Could use `CTFD_NONCE` environment variable instead.\n",
                "secret": true
            },
            "session": {
                "type": "string",
                "description": "User session token, comes with nonce. Could use `CTFD_SESSION` environment variable instead.\n",
                "secret": true
            },
            "url": {
                "type": "string",
                "description": "CTFd base URL (e.g. `https://my-ctf.lan`). Could use `CTFD_URL` environment variable instead.\n"
            }
        },
        "inputProperties": {
            "apiKey": {
                "type": "string",
                "description": "User API key. Could use `CTFD_API_KEY` environment variable instead. Despite being the most convenient way to\nauthenticate yourself, we do not recommend it as you will probably generate a long-live token without any rotation\npolicy.\n",
                "secret": true
            },
            "nonce": {
                "type": "string",
                "description": "User session nonce, comes with session. Could use `CTFD_NONCE` environment variable instead.\n",
                "secret": true
            },
            "session": {
                "type": "string",
                "description": "User session token, comes with nonce. Could use `CTFD_SESSION` environment variable instead.\n",
                "secret": true
            },
            "url": {
                "type": "string",
                "description": "CTFd base URL (e.g. `https://my-ctf.lan`). Could use `CTFD_URL` environment variable instead.\n"
            }
        }
    },
    "resources": {
        "ctfd:index/challenge:Challenge": {
            "description": "CTFd is built around the Challenge resource, which contains all the attributes to define a part of the Capture The Flag event.\n\nThis provider builds a cleaner API on top of CTFd's one to improve its adoption and lifecycle management.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\nimport * as fs from \"fs\";\n\nconst http = new ctfd.Challenge(\"http\", {\n    category: \"misc\",\n    description: \"...\",\n    value: 500,\n    decay: 100,\n    minimum: 50,\n    state: \"visible\",\n    \"function\": \"logarithmic\",\n    topics: [\"Misc\"],\n    tags: [\n        \"misc\",\n        \"basic\",\n    ],\n});\nconst httpFlag = new ctfd.Flag(\"httpFlag\", {\n    challengeId: http.id,\n    content: \"CTF{some_flag}\",\n});\nconst httpHint1 = new ctfd.Hint(\"httpHint1\", {\n    challengeId: http.id,\n    content: \"Some super-helpful hint\",\n    cost: 50,\n});\nconst httpHint2 = new ctfd.Hint(\"httpHint2\", {\n    challengeId: http.id,\n    content: \"Even more helpful hint !\",\n    cost: 50,\n    requirements: [httpHint1.id],\n});\nconst httpFile = new ctfd.File(\"httpFile\", {\n    challengeId: http.id,\n    contentb64: fs.readFileSync(\".../image.png\", { encoding: \"base64\" }),\n});\n```\n```python\nimport pulumi\nimport base64\nimport ctfer-io_pulumi-ctfd as ctfd\n\nhttp = ctfd.Challenge(\"http\",\n    category=\"misc\",\n    description=\"...\",\n    value=500,\n    decay=100,\n    minimum=50,\n    state=\"visible\",\n    function=\"logarithmic\",\n    topics=[\"Misc\"],\n    tags=[\n        \"misc\",\n        \"basic\",\n    ])\nhttp_flag = ctfd.Flag(\"httpFlag\",\n    challenge_id=http.id,\n    content=\"CTF{some_flag}\")\nhttp_hint1 = ctfd.Hint(\"httpHint1\",\n    challenge_id=http.id,\n    content=\"Some super-helpful hint\",\n    cost=50)\nhttp_hint2 = ctfd.Hint(\"httpHint2\",\n    challenge_id=http.id,\n    content=\"Even more helpful hint !\",\n    cost=50,\n    requirements=[http_hint1.id])\nhttp_file = ctfd.File(\"httpFile\",\n    challenge_id=http.id,\n    contentb64=(lambda path: base64.b64encode(open(path).read().encode()).decode())(\".../image.png\"))\n```\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\n\t\nstring ReadFileBase64(string path) \n{\n    return Convert.ToBase64String(Encoding.UTF8.GetBytes(File.ReadAllText(path)));\n}\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var http = new Ctfd.Challenge(\"http\", new()\n    {\n        Category = \"misc\",\n        Description = \"...\",\n        Value = 500,\n        Decay = 100,\n        Minimum = 50,\n        State = \"visible\",\n        Function = \"logarithmic\",\n        Topics = new[]\n        {\n            \"Misc\",\n        },\n        Tags = new[]\n        {\n            \"misc\",\n            \"basic\",\n        },\n    });\n\n    var httpFlag = new Ctfd.Flag(\"httpFlag\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"CTF{some_flag}\",\n    });\n\n    var httpHint1 = new Ctfd.Hint(\"httpHint1\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"Some super-helpful hint\",\n        Cost = 50,\n    });\n\n    var httpHint2 = new Ctfd.Hint(\"httpHint2\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"Even more helpful hint !\",\n        Cost = 50,\n        Requirements = new[]\n        {\n            httpHint1.Id,\n        },\n    });\n\n    var httpFile = new Ctfd.File(\"httpFile\", new()\n    {\n        ChallengeId = http.Id,\n        Contentb64 = ReadFileBase64(\".../image.png\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"os\"\n\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc filebase64OrPanic(path string) string {\n\tif fileData, err := os.ReadFile(path); err == nil {\n\t\treturn base64.StdEncoding.EncodeToString(fileData[:])\n\t} else {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thttp, err := ctfd.NewChallenge(ctx, \"http\", \u0026ctfd.ChallengeArgs{\n\t\t\tCategory:    pulumi.String(\"misc\"),\n\t\t\tDescription: pulumi.String(\"...\"),\n\t\t\tValue:       pulumi.Int(500),\n\t\t\tDecay:       pulumi.Int(100),\n\t\t\tMinimum:     pulumi.Int(50),\n\t\t\tState:       pulumi.String(\"visible\"),\n\t\t\tFunction:    pulumi.String(\"logarithmic\"),\n\t\t\tTopics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Misc\"),\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"misc\"),\n\t\t\t\tpulumi.String(\"basic\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewFlag(ctx, \"httpFlag\", \u0026ctfd.FlagArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"CTF{some_flag}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thttpHint1, err := ctfd.NewHint(ctx, \"httpHint1\", \u0026ctfd.HintArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"Some super-helpful hint\"),\n\t\t\tCost:        pulumi.Int(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewHint(ctx, \"httpHint2\", \u0026ctfd.HintArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"Even more helpful hint !\"),\n\t\t\tCost:        pulumi.Int(50),\n\t\t\tRequirements: pulumi.StringArray{\n\t\t\t\thttpHint1.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewFile(ctx, \"httpFile\", \u0026ctfd.FileArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContentb64:  pulumi.String(filebase64OrPanic(\".../image.png\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.Challenge;\nimport com.pulumi.ctfd.ChallengeArgs;\nimport com.pulumi.ctfd.Flag;\nimport com.pulumi.ctfd.FlagArgs;\nimport com.pulumi.ctfd.Hint;\nimport com.pulumi.ctfd.HintArgs;\nimport com.pulumi.ctfd.File;\nimport com.pulumi.ctfd.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var http = new Challenge(\"http\", ChallengeArgs.builder()\n            .category(\"misc\")\n            .description(\"...\")\n            .value(500)\n            .decay(100)\n            .minimum(50)\n            .state(\"visible\")\n            .function(\"logarithmic\")\n            .topics(\"Misc\")\n            .tags(            \n                \"misc\",\n                \"basic\")\n            .build());\n\n        var httpFlag = new Flag(\"httpFlag\", FlagArgs.builder()\n            .challengeId(http.id())\n            .content(\"CTF{some_flag}\")\n            .build());\n\n        var httpHint1 = new Hint(\"httpHint1\", HintArgs.builder()\n            .challengeId(http.id())\n            .content(\"Some super-helpful hint\")\n            .cost(50)\n            .build());\n\n        var httpHint2 = new Hint(\"httpHint2\", HintArgs.builder()\n            .challengeId(http.id())\n            .content(\"Even more helpful hint !\")\n            .cost(50)\n            .requirements(httpHint1.id())\n            .build());\n\n        var httpFile = new File(\"httpFile\", FileArgs.builder()\n            .challengeId(http.id())\n            .contentb64(Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(\".../image.png\"))))\n            .build());\n\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "category": {
                    "type": "string",
                    "description": "Category of the challenge that CTFd groups by on the web UI.\n"
                },
                "connectionInfo": {
                    "type": "string",
                    "description": "Connection Information to connect to the challenge instance, useful for pwn, web and infrastructure pentests.\n"
                },
                "decay": {
                    "type": "integer",
                    "description": "The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the challenge, consider using multiline descriptions for better style.\n"
                },
                "function": {
                    "type": "string",
                    "description": "Decay function to define how the challenge value evolve through solves, either linear or logarithmic.\n"
                },
                "maxAttempts": {
                    "type": "integer",
                    "description": "Maximum amount of attempts before being unable to flag the challenge.\n"
                },
                "minimum": {
                    "type": "integer",
                    "description": "The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the challenge, displayed as it.\n"
                },
                "next": {
                    "type": "integer",
                    "description": "Suggestion for the end-user as next challenge to work on.\n"
                },
                "requirements": {
                    "$ref": "#/types/ctfd:index/ChallengeRequirements:ChallengeRequirements",
                    "description": "List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the challenge, either hidden or visible.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge topics that are displayed to the administrators for maintenance and planification.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the challenge defining its layout/behavior, either standard or dynamic (default).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "The value (points) of the challenge once solved. Internally, the provider will handle what target is legitimate depending on the `.type` value, i.e. either `value` for \"standard\" or `initial` for \"dynamic\".\n"
                }
            },
            "required": [
                "category",
                "connectionInfo",
                "decay",
                "description",
                "function",
                "maxAttempts",
                "minimum",
                "name",
                "state",
                "tags",
                "topics",
                "type",
                "value"
            ],
            "inputProperties": {
                "category": {
                    "type": "string",
                    "description": "Category of the challenge that CTFd groups by on the web UI.\n"
                },
                "connectionInfo": {
                    "type": "string",
                    "description": "Connection Information to connect to the challenge instance, useful for pwn, web and infrastructure pentests.\n"
                },
                "decay": {
                    "type": "integer",
                    "description": "The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the challenge, consider using multiline descriptions for better style.\n"
                },
                "function": {
                    "type": "string",
                    "description": "Decay function to define how the challenge value evolve through solves, either linear or logarithmic.\n"
                },
                "maxAttempts": {
                    "type": "integer",
                    "description": "Maximum amount of attempts before being unable to flag the challenge.\n"
                },
                "minimum": {
                    "type": "integer",
                    "description": "The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the challenge, displayed as it.\n"
                },
                "next": {
                    "type": "integer",
                    "description": "Suggestion for the end-user as next challenge to work on.\n"
                },
                "requirements": {
                    "$ref": "#/types/ctfd:index/ChallengeRequirements:ChallengeRequirements",
                    "description": "List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the challenge, either hidden or visible.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of challenge topics that are displayed to the administrators for maintenance and planification.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the challenge defining its layout/behavior, either standard or dynamic (default).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "The value (points) of the challenge once solved. Internally, the provider will handle what target is legitimate depending on the `.type` value, i.e. either `value` for \"standard\" or `initial` for \"dynamic\".\n"
                }
            },
            "requiredInputs": [
                "category",
                "description",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Challenge resources.\n",
                "properties": {
                    "category": {
                        "type": "string",
                        "description": "Category of the challenge that CTFd groups by on the web UI.\n"
                    },
                    "connectionInfo": {
                        "type": "string",
                        "description": "Connection Information to connect to the challenge instance, useful for pwn, web and infrastructure pentests.\n"
                    },
                    "decay": {
                        "type": "integer",
                        "description": "The decay defines from each number of solves does the decay function triggers until reaching minimum. This function is defined by CTFd and could be configured through `.function`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the challenge, consider using multiline descriptions for better style.\n"
                    },
                    "function": {
                        "type": "string",
                        "description": "Decay function to define how the challenge value evolve through solves, either linear or logarithmic.\n"
                    },
                    "maxAttempts": {
                        "type": "integer",
                        "description": "Maximum amount of attempts before being unable to flag the challenge.\n"
                    },
                    "minimum": {
                        "type": "integer",
                        "description": "The minimum points for a dynamic-score challenge to reach with the decay function. Once there, no solve could have more value.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the challenge, displayed as it.\n"
                    },
                    "next": {
                        "type": "integer",
                        "description": "Suggestion for the end-user as next challenge to work on.\n"
                    },
                    "requirements": {
                        "$ref": "#/types/ctfd:index/ChallengeRequirements:ChallengeRequirements",
                        "description": "List of required challenges that needs to get flagged before this one being accessible. Useful for skill-trees-like strategy CTF.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the challenge, either hidden or visible.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of challenge tags that will be displayed to the end-user. You could use them to give some quick insights of what a challenge involves.\n"
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of challenge topics that are displayed to the administrators for maintenance and planification.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the challenge defining its layout/behavior, either standard or dynamic (default).\n"
                    },
                    "value": {
                        "type": "integer",
                        "description": "The value (points) of the challenge once solved. Internally, the provider will handle what target is legitimate depending on the `.type` value, i.e. either `value` for \"standard\" or `initial` for \"dynamic\".\n"
                    }
                },
                "type": "object"
            }
        },
        "ctfd:index/file:File": {
            "description": "A CTFd file for a challenge.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\nimport * as fs from \"fs\";\n\nconst http = new ctfd.Challenge(\"http\", {\n    category: \"misc\",\n    description: \"...\",\n    value: 500,\n    decay: 100,\n    minimum: 50,\n    state: \"visible\",\n    \"function\": \"logarithmic\",\n    topics: [\"Misc\"],\n    tags: [\n        \"misc\",\n        \"basic\",\n    ],\n});\nconst httpFile = new ctfd.File(\"httpFile\", {\n    challengeId: http.id,\n    contentb64: fs.readFileSync(\".../image.png\", { encoding: \"base64\" }),\n});\n```\n```python\nimport pulumi\nimport base64\nimport ctfer-io_pulumi-ctfd as ctfd\n\nhttp = ctfd.Challenge(\"http\",\n    category=\"misc\",\n    description=\"...\",\n    value=500,\n    decay=100,\n    minimum=50,\n    state=\"visible\",\n    function=\"logarithmic\",\n    topics=[\"Misc\"],\n    tags=[\n        \"misc\",\n        \"basic\",\n    ])\nhttp_file = ctfd.File(\"httpFile\",\n    challenge_id=http.id,\n    contentb64=(lambda path: base64.b64encode(open(path).read().encode()).decode())(\".../image.png\"))\n```\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\n\t\nstring ReadFileBase64(string path) \n{\n    return Convert.ToBase64String(Encoding.UTF8.GetBytes(File.ReadAllText(path)));\n}\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var http = new Ctfd.Challenge(\"http\", new()\n    {\n        Category = \"misc\",\n        Description = \"...\",\n        Value = 500,\n        Decay = 100,\n        Minimum = 50,\n        State = \"visible\",\n        Function = \"logarithmic\",\n        Topics = new[]\n        {\n            \"Misc\",\n        },\n        Tags = new[]\n        {\n            \"misc\",\n            \"basic\",\n        },\n    });\n\n    var httpFile = new Ctfd.File(\"httpFile\", new()\n    {\n        ChallengeId = http.Id,\n        Contentb64 = ReadFileBase64(\".../image.png\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"os\"\n\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc filebase64OrPanic(path string) string {\n\tif fileData, err := os.ReadFile(path); err == nil {\n\t\treturn base64.StdEncoding.EncodeToString(fileData[:])\n\t} else {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thttp, err := ctfd.NewChallenge(ctx, \"http\", \u0026ctfd.ChallengeArgs{\n\t\t\tCategory:    pulumi.String(\"misc\"),\n\t\t\tDescription: pulumi.String(\"...\"),\n\t\t\tValue:       pulumi.Int(500),\n\t\t\tDecay:       pulumi.Int(100),\n\t\t\tMinimum:     pulumi.Int(50),\n\t\t\tState:       pulumi.String(\"visible\"),\n\t\t\tFunction:    pulumi.String(\"logarithmic\"),\n\t\t\tTopics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Misc\"),\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"misc\"),\n\t\t\t\tpulumi.String(\"basic\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewFile(ctx, \"httpFile\", \u0026ctfd.FileArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContentb64:  pulumi.String(filebase64OrPanic(\".../image.png\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.Challenge;\nimport com.pulumi.ctfd.ChallengeArgs;\nimport com.pulumi.ctfd.File;\nimport com.pulumi.ctfd.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var http = new Challenge(\"http\", ChallengeArgs.builder()\n            .category(\"misc\")\n            .description(\"...\")\n            .value(500)\n            .decay(100)\n            .minimum(50)\n            .state(\"visible\")\n            .function(\"logarithmic\")\n            .topics(\"Misc\")\n            .tags(            \n                \"misc\",\n                \"basic\")\n            .build());\n\n        var httpFile = new File(\"httpFile\", FileArgs.builder()\n            .challengeId(http.id())\n            .contentb64(Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(\".../image.png\"))))\n            .build());\n\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the file.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Raw content of the file, perfectly fit the use-cases of a .txt document or anything with a simple binary content. You could provide it from the file-system using `file(\"${path.module}/...\")`.\n",
                    "secret": true
                },
                "contentb64": {
                    "type": "string",
                    "description": "Base 64 content of the file, perfectly fit the use-cases of complex binaries. You could provide it from the file-system using `filebase64(\"${path.module}/...\")`.\n",
                    "secret": true
                },
                "location": {
                    "type": "string",
                    "description": "Location where the file is stored on the CTFd instance, for download purposes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the file as displayed to end-users.\n"
                },
                "sha1sum": {
                    "type": "string",
                    "description": "The sha1 sum of the file.\n"
                }
            },
            "required": [
                "content",
                "contentb64",
                "location",
                "name",
                "sha1sum"
            ],
            "inputProperties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the file.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Raw content of the file, perfectly fit the use-cases of a .txt document or anything with a simple binary content. You could provide it from the file-system using `file(\"${path.module}/...\")`.\n",
                    "secret": true
                },
                "contentb64": {
                    "type": "string",
                    "description": "Base 64 content of the file, perfectly fit the use-cases of complex binaries. You could provide it from the file-system using `filebase64(\"${path.module}/...\")`.\n",
                    "secret": true
                },
                "location": {
                    "type": "string",
                    "description": "Location where the file is stored on the CTFd instance, for download purposes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the file as displayed to end-users.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "challengeId": {
                        "type": "string",
                        "description": "Challenge of the file.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Raw content of the file, perfectly fit the use-cases of a .txt document or anything with a simple binary content. You could provide it from the file-system using `file(\"${path.module}/...\")`.\n",
                        "secret": true
                    },
                    "contentb64": {
                        "type": "string",
                        "description": "Base 64 content of the file, perfectly fit the use-cases of complex binaries. You could provide it from the file-system using `filebase64(\"${path.module}/...\")`.\n",
                        "secret": true
                    },
                    "location": {
                        "type": "string",
                        "description": "Location where the file is stored on the CTFd instance, for download purposes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the file as displayed to end-users.\n"
                    },
                    "sha1sum": {
                        "type": "string",
                        "description": "The sha1 sum of the file.\n"
                    }
                },
                "type": "object"
            }
        },
        "ctfd:index/flag:Flag": {
            "description": "A flag to solve the challenge.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\n\nconst http = new ctfd.Challenge(\"http\", {\n    category: \"misc\",\n    description: \"...\",\n    value: 500,\n    decay: 100,\n    minimum: 50,\n    state: \"visible\",\n    \"function\": \"logarithmic\",\n    topics: [\"Misc\"],\n    tags: [\n        \"misc\",\n        \"basic\",\n    ],\n});\nconst httpFlag = new ctfd.Flag(\"httpFlag\", {\n    challengeId: http.id,\n    content: \"CTF{some_flag}\",\n});\n```\n```python\nimport pulumi\nimport ctfer-io_pulumi-ctfd as ctfd\n\nhttp = ctfd.Challenge(\"http\",\n    category=\"misc\",\n    description=\"...\",\n    value=500,\n    decay=100,\n    minimum=50,\n    state=\"visible\",\n    function=\"logarithmic\",\n    topics=[\"Misc\"],\n    tags=[\n        \"misc\",\n        \"basic\",\n    ])\nhttp_flag = ctfd.Flag(\"httpFlag\",\n    challenge_id=http.id,\n    content=\"CTF{some_flag}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var http = new Ctfd.Challenge(\"http\", new()\n    {\n        Category = \"misc\",\n        Description = \"...\",\n        Value = 500,\n        Decay = 100,\n        Minimum = 50,\n        State = \"visible\",\n        Function = \"logarithmic\",\n        Topics = new[]\n        {\n            \"Misc\",\n        },\n        Tags = new[]\n        {\n            \"misc\",\n            \"basic\",\n        },\n    });\n\n    var httpFlag = new Ctfd.Flag(\"httpFlag\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"CTF{some_flag}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thttp, err := ctfd.NewChallenge(ctx, \"http\", \u0026ctfd.ChallengeArgs{\n\t\t\tCategory:    pulumi.String(\"misc\"),\n\t\t\tDescription: pulumi.String(\"...\"),\n\t\t\tValue:       pulumi.Int(500),\n\t\t\tDecay:       pulumi.Int(100),\n\t\t\tMinimum:     pulumi.Int(50),\n\t\t\tState:       pulumi.String(\"visible\"),\n\t\t\tFunction:    pulumi.String(\"logarithmic\"),\n\t\t\tTopics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Misc\"),\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"misc\"),\n\t\t\t\tpulumi.String(\"basic\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewFlag(ctx, \"httpFlag\", \u0026ctfd.FlagArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"CTF{some_flag}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.Challenge;\nimport com.pulumi.ctfd.ChallengeArgs;\nimport com.pulumi.ctfd.Flag;\nimport com.pulumi.ctfd.FlagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var http = new Challenge(\"http\", ChallengeArgs.builder()\n            .category(\"misc\")\n            .description(\"...\")\n            .value(500)\n            .decay(100)\n            .minimum(50)\n            .state(\"visible\")\n            .function(\"logarithmic\")\n            .topics(\"Misc\")\n            .tags(            \n                \"misc\",\n                \"basic\")\n            .build());\n\n        var httpFlag = new Flag(\"httpFlag\", FlagArgs.builder()\n            .challengeId(http.id())\n            .content(\"CTF{some_flag}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  http:\n    type: ctfd:Challenge\n    properties:\n      category: misc\n      description: '...'\n      value: 500\n      decay: 100\n      minimum: 50\n      state: visible\n      function: logarithmic\n      topics:\n        - Misc\n      tags:\n        - misc\n        - basic\n  httpFlag:\n    type: ctfd:Flag\n    properties:\n      challengeId: ${http.id}\n      content: CTF{some_flag}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the flag.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The actual flag to match. Consider using the convention `MYCTF{value}` with `MYCTF` being the shortcode of your event's name and `value` depending on each challenge.\n",
                    "secret": true
                },
                "data": {
                    "type": "string",
                    "description": "The flag sensitivity information, either case*sensitive or case*insensitive\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the flag, could be either static or regex\n"
                }
            },
            "required": [
                "challengeId",
                "content",
                "data",
                "type"
            ],
            "inputProperties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the flag.\n"
                },
                "content": {
                    "type": "string",
                    "description": "The actual flag to match. Consider using the convention `MYCTF{value}` with `MYCTF` being the shortcode of your event's name and `value` depending on each challenge.\n",
                    "secret": true
                },
                "data": {
                    "type": "string",
                    "description": "The flag sensitivity information, either case*sensitive or case*insensitive\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the flag, could be either static or regex\n"
                }
            },
            "requiredInputs": [
                "challengeId",
                "content"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Flag resources.\n",
                "properties": {
                    "challengeId": {
                        "type": "string",
                        "description": "Challenge of the flag.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "The actual flag to match. Consider using the convention `MYCTF{value}` with `MYCTF` being the shortcode of your event's name and `value` depending on each challenge.\n",
                        "secret": true
                    },
                    "data": {
                        "type": "string",
                        "description": "The flag sensitivity information, either case*sensitive or case*insensitive\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the flag, could be either static or regex\n"
                    }
                },
                "type": "object"
            }
        },
        "ctfd:index/hint:Hint": {
            "description": "A hint for a challenge to help players solve it.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\n\nconst http = new ctfd.Challenge(\"http\", {\n    category: \"misc\",\n    description: \"...\",\n    value: 500,\n    decay: 100,\n    minimum: 50,\n    state: \"visible\",\n    \"function\": \"logarithmic\",\n    topics: [\"Misc\"],\n    tags: [\n        \"misc\",\n        \"basic\",\n    ],\n});\nconst httpFlag = new ctfd.Flag(\"httpFlag\", {\n    challengeId: http.id,\n    content: \"CTF{some_flag}\",\n});\nconst httpHint = new ctfd.Hint(\"httpHint\", {\n    challengeId: http.id,\n    content: \"Some super-helpful hint\",\n    cost: 50,\n});\nconst httpHint2 = new ctfd.Hint(\"httpHint2\", {\n    challengeId: http.id,\n    content: \"Even more helpful hint !\",\n    cost: 50,\n    requirements: [ctfd_hint.http_hint_1.id],\n});\n```\n```python\nimport pulumi\nimport ctfer-io_pulumi-ctfd as ctfd\n\nhttp = ctfd.Challenge(\"http\",\n    category=\"misc\",\n    description=\"...\",\n    value=500,\n    decay=100,\n    minimum=50,\n    state=\"visible\",\n    function=\"logarithmic\",\n    topics=[\"Misc\"],\n    tags=[\n        \"misc\",\n        \"basic\",\n    ])\nhttp_flag = ctfd.Flag(\"httpFlag\",\n    challenge_id=http.id,\n    content=\"CTF{some_flag}\")\nhttp_hint = ctfd.Hint(\"httpHint\",\n    challenge_id=http.id,\n    content=\"Some super-helpful hint\",\n    cost=50)\nhttp_hint2 = ctfd.Hint(\"httpHint2\",\n    challenge_id=http.id,\n    content=\"Even more helpful hint !\",\n    cost=50,\n    requirements=[ctfd_hint[\"http_hint_1\"][\"id\"]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var http = new Ctfd.Challenge(\"http\", new()\n    {\n        Category = \"misc\",\n        Description = \"...\",\n        Value = 500,\n        Decay = 100,\n        Minimum = 50,\n        State = \"visible\",\n        Function = \"logarithmic\",\n        Topics = new[]\n        {\n            \"Misc\",\n        },\n        Tags = new[]\n        {\n            \"misc\",\n            \"basic\",\n        },\n    });\n\n    var httpFlag = new Ctfd.Flag(\"httpFlag\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"CTF{some_flag}\",\n    });\n\n    var httpHint = new Ctfd.Hint(\"httpHint\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"Some super-helpful hint\",\n        Cost = 50,\n    });\n\n    var httpHint2 = new Ctfd.Hint(\"httpHint2\", new()\n    {\n        ChallengeId = http.Id,\n        Content = \"Even more helpful hint !\",\n        Cost = 50,\n        Requirements = new[]\n        {\n            ctfd_hint.Http_hint_1.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thttp, err := ctfd.NewChallenge(ctx, \"http\", \u0026ctfd.ChallengeArgs{\n\t\t\tCategory:    pulumi.String(\"misc\"),\n\t\t\tDescription: pulumi.String(\"...\"),\n\t\t\tValue:       pulumi.Int(500),\n\t\t\tDecay:       pulumi.Int(100),\n\t\t\tMinimum:     pulumi.Int(50),\n\t\t\tState:       pulumi.String(\"visible\"),\n\t\t\tFunction:    pulumi.String(\"logarithmic\"),\n\t\t\tTopics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Misc\"),\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"misc\"),\n\t\t\t\tpulumi.String(\"basic\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewFlag(ctx, \"httpFlag\", \u0026ctfd.FlagArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"CTF{some_flag}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewHint(ctx, \"httpHint\", \u0026ctfd.HintArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"Some super-helpful hint\"),\n\t\t\tCost:        pulumi.Int(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewHint(ctx, \"httpHint2\", \u0026ctfd.HintArgs{\n\t\t\tChallengeId: http.ID(),\n\t\t\tContent:     pulumi.String(\"Even more helpful hint !\"),\n\t\t\tCost:        pulumi.Int(50),\n\t\t\tRequirements: pulumi.StringArray{\n\t\t\t\tctfd_hint.Http_hint_1.Id,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.Challenge;\nimport com.pulumi.ctfd.ChallengeArgs;\nimport com.pulumi.ctfd.Flag;\nimport com.pulumi.ctfd.FlagArgs;\nimport com.pulumi.ctfd.Hint;\nimport com.pulumi.ctfd.HintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var http = new Challenge(\"http\", ChallengeArgs.builder()\n            .category(\"misc\")\n            .description(\"...\")\n            .value(500)\n            .decay(100)\n            .minimum(50)\n            .state(\"visible\")\n            .function(\"logarithmic\")\n            .topics(\"Misc\")\n            .tags(            \n                \"misc\",\n                \"basic\")\n            .build());\n\n        var httpFlag = new Flag(\"httpFlag\", FlagArgs.builder()\n            .challengeId(http.id())\n            .content(\"CTF{some_flag}\")\n            .build());\n\n        var httpHint = new Hint(\"httpHint\", HintArgs.builder()\n            .challengeId(http.id())\n            .content(\"Some super-helpful hint\")\n            .cost(50)\n            .build());\n\n        var httpHint2 = new Hint(\"httpHint2\", HintArgs.builder()\n            .challengeId(http.id())\n            .content(\"Even more helpful hint !\")\n            .cost(50)\n            .requirements(ctfd_hint.http_hint_1().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  http:\n    type: ctfd:Challenge\n    properties:\n      category: misc\n      description: '...'\n      value: 500\n      decay: 100\n      minimum: 50\n      state: visible\n      function: logarithmic\n      topics:\n        - Misc\n      tags:\n        - misc\n        - basic\n  httpFlag:\n    type: ctfd:Flag\n    properties:\n      challengeId: ${http.id}\n      content: CTF{some_flag}\n  httpHint:\n    type: ctfd:Hint\n    properties:\n      challengeId: ${http.id}\n      content: Some super-helpful hint\n      cost: 50\n  httpHint2:\n    type: ctfd:Hint\n    properties:\n      challengeId: ${http.id}\n      content: Even more helpful hint !\n      cost: 50\n      requirements:\n        - ${ctfd_hint.http_hint_1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the hint.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Content of the hint as displayed to the end-user.\n"
                },
                "cost": {
                    "type": "integer",
                    "description": "Cost of the hint, and if any specified, the end-user will consume its own (or team) points to get it.\n"
                },
                "requirements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the other hints it depends on.\n"
                }
            },
            "required": [
                "challengeId",
                "content",
                "cost",
                "requirements"
            ],
            "inputProperties": {
                "challengeId": {
                    "type": "string",
                    "description": "Challenge of the hint.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Content of the hint as displayed to the end-user.\n"
                },
                "cost": {
                    "type": "integer",
                    "description": "Cost of the hint, and if any specified, the end-user will consume its own (or team) points to get it.\n"
                },
                "requirements": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the other hints it depends on.\n"
                }
            },
            "requiredInputs": [
                "challengeId",
                "content"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Hint resources.\n",
                "properties": {
                    "challengeId": {
                        "type": "string",
                        "description": "Challenge of the hint.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Content of the hint as displayed to the end-user.\n"
                    },
                    "cost": {
                        "type": "integer",
                        "description": "Cost of the hint, and if any specified, the end-user will consume its own (or team) points to get it.\n"
                    },
                    "requirements": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of the other hints it depends on.\n"
                    }
                },
                "type": "object"
            }
        },
        "ctfd:index/team:Team": {
            "description": "CTFd defines a Team as a group of Users who will attend the Capture The Flag event.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\n\nconst ctfer = new ctfd.User(\"ctfer\", {\n    email: \"ctfer-io@protonmail.com\",\n    password: \"password\",\n});\nconst cybercombattants = new ctfd.Team(\"cybercombattants\", {\n    email: \"lucastesson@protonmail.com\",\n    password: \"password\",\n    members: [ctfer.id],\n    captain: ctfer.id,\n});\n```\n```python\nimport pulumi\nimport ctfer-io_pulumi-ctfd as ctfd\n\nctfer = ctfd.User(\"ctfer\",\n    email=\"ctfer-io@protonmail.com\",\n    password=\"password\")\ncybercombattants = ctfd.Team(\"cybercombattants\",\n    email=\"lucastesson@protonmail.com\",\n    password=\"password\",\n    members=[ctfer.id],\n    captain=ctfer.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ctfer = new Ctfd.User(\"ctfer\", new()\n    {\n        Email = \"ctfer-io@protonmail.com\",\n        Password = \"password\",\n    });\n\n    var cybercombattants = new Ctfd.Team(\"cybercombattants\", new()\n    {\n        Email = \"lucastesson@protonmail.com\",\n        Password = \"password\",\n        Members = new[]\n        {\n            ctfer.Id,\n        },\n        Captain = ctfer.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctfer, err := ctfd.NewUser(ctx, \"ctfer\", \u0026ctfd.UserArgs{\n\t\t\tEmail:    pulumi.String(\"ctfer-io@protonmail.com\"),\n\t\t\tPassword: pulumi.String(\"password\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ctfd.NewTeam(ctx, \"cybercombattants\", \u0026ctfd.TeamArgs{\n\t\t\tEmail:    pulumi.String(\"lucastesson@protonmail.com\"),\n\t\t\tPassword: pulumi.String(\"password\"),\n\t\t\tMembers: pulumi.StringArray{\n\t\t\t\tctfer.ID(),\n\t\t\t},\n\t\t\tCaptain: ctfer.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.User;\nimport com.pulumi.ctfd.UserArgs;\nimport com.pulumi.ctfd.Team;\nimport com.pulumi.ctfd.TeamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ctfer = new User(\"ctfer\", UserArgs.builder()\n            .email(\"ctfer-io@protonmail.com\")\n            .password(\"password\")\n            .build());\n\n        var cybercombattants = new Team(\"cybercombattants\", TeamArgs.builder()\n            .email(\"lucastesson@protonmail.com\")\n            .password(\"password\")\n            .members(ctfer.id())\n            .captain(ctfer.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ctfer:\n    type: ctfd:User\n    properties:\n      email: ctfer-io@protonmail.com\n      password: password\n  cybercombattants:\n    type: ctfd:Team\n    properties:\n      email: lucastesson@protonmail.com\n      password: password\n      members:\n        - ${ctfer.id}\n      captain: ${ctfer.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "affiliation": {
                    "type": "string",
                    "description": "Affiliation to a company or agency.\n"
                },
                "banned": {
                    "type": "boolean",
                    "description": "Is true if the team is banned from the CTF.\n"
                },
                "captain": {
                    "type": "string",
                    "description": "Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).\n"
                },
                "country": {
                    "type": "string",
                    "description": "Country the team represent or is hail from.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email of the team.\n"
                },
                "hidden": {
                    "type": "boolean",
                    "description": "Is true if the team is hidden to the participants.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of members (User), defined by their IDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the team.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.\n"
                },
                "website": {
                    "type": "string",
                    "description": "Website, blog, or anything similar (displayed to other participants).\n"
                }
            },
            "required": [
                "banned",
                "captain",
                "email",
                "hidden",
                "members",
                "name",
                "password"
            ],
            "inputProperties": {
                "affiliation": {
                    "type": "string",
                    "description": "Affiliation to a company or agency.\n"
                },
                "banned": {
                    "type": "boolean",
                    "description": "Is true if the team is banned from the CTF.\n"
                },
                "captain": {
                    "type": "string",
                    "description": "Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).\n"
                },
                "country": {
                    "type": "string",
                    "description": "Country the team represent or is hail from.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email of the team.\n"
                },
                "hidden": {
                    "type": "boolean",
                    "description": "Is true if the team is hidden to the participants.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of members (User), defined by their IDs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the team.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.\n"
                },
                "website": {
                    "type": "string",
                    "description": "Website, blog, or anything similar (displayed to other participants).\n"
                }
            },
            "requiredInputs": [
                "captain",
                "email",
                "members",
                "password"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "affiliation": {
                        "type": "string",
                        "description": "Affiliation to a company or agency.\n"
                    },
                    "banned": {
                        "type": "boolean",
                        "description": "Is true if the team is banned from the CTF.\n"
                    },
                    "captain": {
                        "type": "string",
                        "description": "Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "Country the team represent or is hail from.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "Email of the team.\n"
                    },
                    "hidden": {
                        "type": "boolean",
                        "description": "Is true if the team is hidden to the participants.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of members (User), defined by their IDs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the team.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.\n"
                    },
                    "website": {
                        "type": "string",
                        "description": "Website, blog, or anything similar (displayed to other participants).\n"
                    }
                },
                "type": "object"
            }
        },
        "ctfd:index/user:User": {
            "description": "CTFd defines a User as someone who will either play or administrate the Capture The Flag event.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ctfd from \"@ctfer-io/pulumi-ctfd\";\n\nconst ctfer = new ctfd.User(\"ctfer\", {\n    email: \"ctfer-io@protonmail.com\",\n    hidden: true,\n    password: \"password\",\n    type: \"admin\",\n    verified: true,\n});\n```\n```python\nimport pulumi\nimport ctfer-io_pulumi-ctfd as ctfd\n\nctfer = ctfd.User(\"ctfer\",\n    email=\"ctfer-io@protonmail.com\",\n    hidden=True,\n    password=\"password\",\n    type=\"admin\",\n    verified=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ctfd = CTFerio.Ctfd;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ctfer = new Ctfd.User(\"ctfer\", new()\n    {\n        Email = \"ctfer-io@protonmail.com\",\n        Hidden = true,\n        Password = \"password\",\n        Type = \"admin\",\n        Verified = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ctfer-io/pulumi-ctfd/sdk/go/ctfd\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ctfd.NewUser(ctx, \"ctfer\", \u0026ctfd.UserArgs{\n\t\t\tEmail:    pulumi.String(\"ctfer-io@protonmail.com\"),\n\t\t\tHidden:   pulumi.Bool(true),\n\t\t\tPassword: pulumi.String(\"password\"),\n\t\t\tType:     pulumi.String(\"admin\"),\n\t\t\tVerified: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ctfd.User;\nimport com.pulumi.ctfd.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ctfer = new User(\"ctfer\", UserArgs.builder()\n            .email(\"ctfer-io@protonmail.com\")\n            .hidden(true)\n            .password(\"password\")\n            .type(\"admin\")\n            .verified(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ctfer:\n    type: ctfd:User\n    properties:\n      email: ctfer-io@protonmail.com\n      hidden: true\n      password: password\n      # Make the user administrator of the CTFd instance\n      type: admin\n      verified: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "affiliation": {
                    "type": "string",
                    "description": "Affiliation to a team, company or agency.\n"
                },
                "banned": {
                    "type": "boolean",
                    "description": "Is true if the user is banned from the CTF.\n"
                },
                "country": {
                    "type": "string",
                    "description": "Country the user represent or is native from.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email of the user, may be used to verify the account.\n",
                    "secret": true
                },
                "hidden": {
                    "type": "boolean",
                    "description": "Is true if the user is hidden to the participants.\n"
                },
                "language": {
                    "type": "string",
                    "description": "Language the user is fluent in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name or pseudo of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the user. Notice than during a CTF you may not want to update those to avoid defaulting user accesses.\n",
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "Generic type for RBAC purposes.\n"
                },
                "verified": {
                    "type": "boolean",
                    "description": "Is true if the user has verified its account by email, or if set by an admin.\n"
                },
                "website": {
                    "type": "string",
                    "description": "Website, blog, or anything similar (displayed to other participants).\n"
                }
            },
            "required": [
                "banned",
                "email",
                "hidden",
                "name",
                "password",
                "type",
                "verified"
            ],
            "inputProperties": {
                "affiliation": {
                    "type": "string",
                    "description": "Affiliation to a team, company or agency.\n"
                },
                "banned": {
                    "type": "boolean",
                    "description": "Is true if the user is banned from the CTF.\n"
                },
                "country": {
                    "type": "string",
                    "description": "Country the user represent or is native from.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email of the user, may be used to verify the account.\n",
                    "secret": true
                },
                "hidden": {
                    "type": "boolean",
                    "description": "Is true if the user is hidden to the participants.\n"
                },
                "language": {
                    "type": "string",
                    "description": "Language the user is fluent in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name or pseudo of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the user. Notice than during a CTF you may not want to update those to avoid defaulting user accesses.\n",
                    "secret": true
                },
                "type": {
                    "type": "string",
                    "description": "Generic type for RBAC purposes.\n"
                },
                "verified": {
                    "type": "boolean",
                    "description": "Is true if the user has verified its account by email, or if set by an admin.\n"
                },
                "website": {
                    "type": "string",
                    "description": "Website, blog, or anything similar (displayed to other participants).\n"
                }
            },
            "requiredInputs": [
                "email",
                "password"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "affiliation": {
                        "type": "string",
                        "description": "Affiliation to a team, company or agency.\n"
                    },
                    "banned": {
                        "type": "boolean",
                        "description": "Is true if the user is banned from the CTF.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "Country the user represent or is native from.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "Email of the user, may be used to verify the account.\n",
                        "secret": true
                    },
                    "hidden": {
                        "type": "boolean",
                        "description": "Is true if the user is hidden to the participants.\n"
                    },
                    "language": {
                        "type": "string",
                        "description": "Language the user is fluent in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name or pseudo of the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password of the user. Notice than during a CTF you may not want to update those to avoid defaulting user accesses.\n",
                        "secret": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Generic type for RBAC purposes.\n"
                    },
                    "verified": {
                        "type": "boolean",
                        "description": "Is true if the user has verified its account by email, or if set by an admin.\n"
                    },
                    "website": {
                        "type": "string",
                        "description": "Website, blog, or anything similar (displayed to other participants).\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "ctfd:index/getChallenges:getChallenges": {
            "outputs": {
                "description": "A collection of values returned by getChallenges.\n",
                "properties": {
                    "challenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ctfd:index/getChallengesChallenge:getChallengesChallenge"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of this resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "challenges",
                    "id"
                ]
            }
        },
        "ctfd:index/getTeams:getTeams": {
            "outputs": {
                "description": "A collection of values returned by getTeams.\n",
                "properties": {
                    "affiliation": {
                        "type": "string",
                        "description": "Affiliation to a company or agency.\n"
                    },
                    "banned": {
                        "type": "boolean",
                        "description": "Is true if the team is banned from the CTF.\n"
                    },
                    "captain": {
                        "type": "string",
                        "description": "Member who is captain of the team. Must be part of the members too. Note it could cause a fatal error in case of resource import with an inconsistent CTFd configuration i.e. if a team has no captain yet (should not be possible).\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "Country the team represent or is hail from.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "Email of the team.\n"
                    },
                    "hidden": {
                        "type": "boolean",
                        "description": "Is true if the team is hidden to the participants.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Identifier of the user.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of members (User), defined by their IDs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the team.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password of the team. Notice that during a CTF you may not want to update those to avoid defaulting team accesses.\n"
                    },
                    "website": {
                        "type": "string",
                        "description": "Website, blog, or anything similar (displayed to other participants).\n"
                    }
                },
                "type": "object",
                "required": [
                    "affiliation",
                    "banned",
                    "captain",
                    "country",
                    "email",
                    "hidden",
                    "id",
                    "members",
                    "name",
                    "password",
                    "website"
                ]
            }
        },
        "ctfd:index/getUsers:getUsers": {
            "outputs": {
                "description": "A collection of values returned by getUsers.\n",
                "properties": {
                    "affiliation": {
                        "type": "string",
                        "description": "Affiliation to a team, company or agency.\n"
                    },
                    "banned": {
                        "type": "boolean",
                        "description": "Is true if the user is banned from the CTF.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "Country the user represent or is native from.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "Email of the user, may be used to verify the account.\n"
                    },
                    "hidden": {
                        "type": "boolean",
                        "description": "Is true if the user is hidden to the participants.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Identifier of the user.\n"
                    },
                    "language": {
                        "type": "string",
                        "description": "Language the user is fluent in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name or pseudo of the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password of the user. Notice that during a CTF you may not want to update those to avoid defaulting user accesses.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Generic type for RBAC purposes.\n"
                    },
                    "verified": {
                        "type": "boolean",
                        "description": "Is true if the user has verified its account by email, or if set by an admin.\n"
                    },
                    "website": {
                        "type": "string",
                        "description": "Website, blog, or anything similar (displayed to other participants).\n"
                    }
                },
                "type": "object",
                "required": [
                    "affiliation",
                    "banned",
                    "country",
                    "email",
                    "hidden",
                    "id",
                    "language",
                    "name",
                    "password",
                    "type",
                    "verified",
                    "website"
                ]
            }
        }
    }
}